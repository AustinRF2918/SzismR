/*
 * This is a portion for parsing into a hashmap
 * our parsed rc and allowing the user to call
 * pass it back to our main caller for the user
 * to do stuff with.
*/



pub mod parse{

    extern crate regex;
    use regex::Regex;
    use std::collections::HashMap;
    use std::path::PathBuf;
    use std::fs::File;
    use std::io::Read;
    use std::str;
    use std::slice;


    //This is the "Pluginable" Portion of our code.
    enum ParseState{
        ParseBeginDenoter(Regex),
        ParsePackPath(Regex),
        ParseScriptsDenoter(Regex),
        ParseEntryDenoter(Regex),
        ParseEntryPath(Regex),
        ParseScriptPath(Regex),
        ParseDescopeDenoter(Regex),
        ParseEndDenoter(Regex),
    }
    
    struct lineParseMatrix{
        //Put enumerative state and it's possbile edges (other states
        //with regex to say "yes you can do that".

        //                Our Node        Our Edge
        mat_map : HashMap<ParseState, Vec<ParseState>>,
        //Scheme:
        //    1. ParseBegin ------> get vector back
        //    2. run through vector, does it(erator) pass regex? -----> parse_state = this.
        //    3. not found?
        //        4. is it conservative?
        //            Yes -> Crash Program.
        //            No  -> Mantain State.
        //    otherwise...    
        //    4. Has a signal been sent that we are done?
        //    5. If yes, check for finish state.
        //    6. not finish state?
        //        7. is it conservative?
        //            Yes -> Crash Program.
        //            No  -> Force End State.
        //    otherwise...
        //    8. go-to 1

        parse_state : ParseState,
        is_conservative : bool,
        parse_scope: i32, //We could do this with states, but this is way easier.
    }
    
    //TODO - allow lineParseMatrix to be pushed states.
    //Use an enum instead of a string that contains a regex
    //and a string. This will probably be way more expandable.
    
    
    struct lineParseMap{
        //Not sure if these have to be mutable like this..
        parse_map : HashMap<String, Regex>,
        parse_state : String,
        parse_state_regex : Regex,
        is_conservative : bool
    }

    impl lineParseMap{
        pub fn new(mut self) -> lineParseMap{
            //By default our parser is "Conservative"
            //That means that if we come to a state
            //we don't have an answer for, or parser
            //crashes. Otherwise it will continue and
            //simply not change state.

            self.is_conservative = true;
            self
        }

        pub fn push_mapping(&mut self, state : String, re : Regex)
        {
            self.parse_map.insert(state, re);
        }

        pub fn set_liberal(&mut self)
        {
            self.is_conservative = false;
        }

        pub fn switch_state(&mut self, state : String, debug : bool) 
        {
            if self.parse_map.contains_key(&state){
                if debug{
                        println!("Parser to: {} going from: {}", state, &self.parse_state);
                }
                self.parse_state = state;
            }
            else{
                if self.is_conservative
                {
                    panic!("Parser set on conservative mode found unparsable input: {} at state : {}", state, &self.parse_state);

                }
                else
                {
                    if debug{
                        println!("Parser set on liberal mode found unparsable input: {} at state : {}", state, &self.parse_state);

                    }

                }

            }
        }
    }
        
    pub struct hash_parser
    {
        tokens:  Vec<String>,
    }

    impl hash_parser{
        pub fn new() -> hash_parser{
                hash_parser{
                tokens : Vec::new(),
            }
        }

        pub fn parse_rc(&self, root : &PathBuf, debug : bool) -> HashMap<String, String>
        {


            //We're gonna return a new path without destroying our old root.
            let mut ret_path = root.clone();
            let mut slice = &mut String::new();
            let mut ret_hash : HashMap<String, String> = HashMap::new();

            let rc_data = match File::open(&ret_path){
                Ok(mut f) => {


                    f.read_to_string(slice).unwrap();
                    {
                        //Parse tokens by new line.
                        let tokens : Vec<&str> = slice.split('\n').collect();

                        let p_pack = regex::Regex::new(r"(.*)\.parsePack").unwrap();
                        let p_ms_entry = regex::Regex::new(r"(.*)\.parseScripts").unwrap();
                        let p_s_entry = regex::Regex::new(r"(?P<script_caller>.*)\^entryPoint").unwrap();
                        let p_descope = regex::Regex::new(r"(.*)End").unwrap();
                        let s_entry = regex::Regex::new(r"(?P<script_entry>.*)").unwrap();
                        let s_dependancy = regex::Regex::new(r"(.*)").unwrap();

                        let mut scope = 0;

                        let mut current_key = String::new();
                        let mut current_path = String::new();


                        //Simple C++ Style enum, no fancy stuff.
                        //
                        //General State Information and possbilities.
                        enum State {
                            Begin,
                            End,
                            ParsingPack,
                            ParsingScriptEntry,
                            ParsingScripts,
                            ParsingDescope,
                            ParsingEntry,
                            ParsingDependancy,
                        }

                        //*************************************************//
                        //------------   These are simply guided ----------//
                        //------------   states, we only need    ----------//
                        //------------   one enum to represent   ----------//
                        //------------   this.                   ----------//
                        //*************************************************//
                        /////////////////////////////////////////////////////
                        //Our being state that can lead to other stuff :)
                        //enum Begin
                        //{
                        //    ParsingPack,
                        //    End,
                        //}

                        //Our parsing a full plugin pack state.
                        //enum ParsingPack
                        //{
                        //    ParsingScriptEntry,
                        //    ParsingScripts,
                        //    ParsingDescope,
                        //}

                        //Script entry state: One way.
                        //enum ParsingScriptEntry
                        //{
                        //    ParsingScript,
                        //}

                        //Parsing script state. For parsing single scripts.
                        //enum ParsingScript
                        //{
                        //    ParsingScript,
                        //    ParsingDescope,
                        //    ParsingScriptEntry,
                        //}

                        //All our ends and descopes, don't confuse End with descoping.
                        //end signifies end of input and that our file may no longer read.
                        //enum ParsingDescope
                        //{
                        //    ParsingDescope,
                        //    ParsingPack,
                        //    ParsingScripts,
                        //    End
                        //}
                        ///////////////////////////////////////////////////////

                        let mut fsa: State = State::Begin;

                        //NOTES:
                        //IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
                        //Preferably we package this into a simplified Finite State Machine
                        //Library for producting simple states and objects to hold these states
                        //using idomatic Rust. But for now I am just gonna use this simple
                        //match/if cases. I Should probably also create more descriptive
                        //error messages.
                        //IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
                        for i in tokens
                        {
                            match fsa{
                                State::Begin => {
                                    if p_pack.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingPack");
                                        }

                                        scope += 1;
                                        fsa = State::ParsingPack;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }

                                },
                                State::ParsingPack => {
                                    if p_ms_entry.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingScripts");
                                        }

                                        scope += 1;
                                         fsa = State::ParsingScripts;
                                    }
                                    else if p_descope.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingDescope");
                                        }

                                        scope -= 1;
                                        fsa = State::ParsingDescope;
                                    }
                                    else if p_s_entry.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingScriptEntry");
                                        }

                                         fsa = State::ParsingScriptEntry;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }

                                },

                                State::ParsingScripts => {
                                    if p_descope.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingDescope");
                                        }

                                        scope -= 1;
                                        fsa = State::ParsingDescope;
                                    }
                                    else if p_s_entry.is_match(i)
                                    {
                                        let key_capture = p_s_entry.captures(i).unwrap();
                                        current_key = key_capture.name("script_caller").unwrap().replace("\n", "").replace("\r", "").trim().to_string();

                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingScriptEntry");
                                        }

                                         fsa = State::ParsingScriptEntry;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }
                                },

                                State::ParsingScriptEntry => {
                                    if s_entry.is_match(i)
                                    {
                                        let path_capture = s_entry.captures(i).unwrap();
                                        current_path = path_capture.name("script_entry").unwrap().replace("\n", "").replace("\r", "").trim().to_string();

                                        ret_hash.insert(current_key.to_string(), current_path.to_string());

                                        //Push key value pair.
                                        if debug
                                        {
                                            println!("value being added: {}", &current_key);
                                            println!("path being added: {}", &current_path);
                                            println!("Parsing RC: Current State: ParsingEntry");
                                        }

                                        fsa = State::ParsingEntry;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }
                                },
                                State::ParsingEntry => {
                                    if p_descope.is_match(i)
                                    {
                                        if debug
                                        {
                                             println!("Parsing RC: Current State: ParsingDescope ");
                                        }

                                        scope -= 1;
                                        fsa = State::ParsingDescope;
                                    }
                                    else if s_dependancy.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingDependancy");
                                        }

                                        fsa = State::ParsingDependancy;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }
                                },
                                State::ParsingDependancy => {

                                    if p_descope.is_match(i)
                                    {
                                        if debug
                                        {
                                             println!("Parsing RC: Current State: ParsingDescope ");
                                        }

                                        scope -= 1;
                                        fsa = State::ParsingDescope;
                                    }
                                    else if p_s_entry.is_match(i)
                                    {
                                        if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingEntry");
                                        }

                                        fsa = State::ParsingEntry;
                                    }
                                    else if s_dependancy.is_match(i)
                                    {
                                         if debug
                                        {
                                            println!("Parsing RC: Current State: ParsingDependancy");
                                        }

                                        fsa = State::ParsingDependancy;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }
                                },
                                State::ParsingDescope => {
                                    if p_descope.is_match(i)
                                    {
                                        if debug
                                        {
                                             println!("Parsing RC: Current State: ParsingDescope");
                                        }

                                        scope -= 1;
                                        fsa = State::ParsingDescope;
                                    }
                                    else if p_pack.is_match(i)
                                    {
                                        if debug
                                        {
                                             println!("Parsing RC: Currennt State: ParsingPack");
                                        }

                                        scope += 1;
                                        fsa = State::ParsingPack;
                                    }
                                    else if p_ms_entry.is_match(i)
                                    {
                                        if debug
                                        {
                                             println!("Parsing RC: Current State: ParsingScripts");
                                        }

                                        scope += 1;
                                         fsa = State::ParsingScripts;
                                    }
                                    else if scope == 0
                                    {
                                        println!("Done");
                                        fsa = State::End;
                                    }
                                    else
                                    {
                                         panic!("Your RC Files syntax is corrupt.");
                                    }
                                },
                                State::End => {
                                         println!("Done");
                                }
                            }
                                //match i
                                //{
                                //    p_pack.is_match(i) => {
                                //        println!("Parsing Pack :{}", i.trim());
                                //    },
                                //    p_s_entry(i) => {
                                //        println!("Parsing Script Entry Point: {}", i.trim());
                                //    },
                                //    p_script(i) => {
                                //        println!("Parsing Scripts: {}", i.trim());
                                //    },
                                //    p_descope(i) => {
                                //        println!("Descope: {}", i.trim());
                                //    },
                                //    _ => {
                                //        println!("Error: {}", i.trim());
                                //    }
                        }
                        if debug
                        {
                            println!(" ");
                            println!("      _____PASSED RC_________");
                            println!(" ");
                        }
                    }
                },
                Err(e) => {
                     println!("Failed to open RC file: {}", e);
                }
            };
            ret_hash
        }
    }
}
